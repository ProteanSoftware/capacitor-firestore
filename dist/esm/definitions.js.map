{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AAAA,wCAAwC;AA0CxC;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CAAC,KAAa,EAAE,QAAwB,EAAE,KAAU;IACvF,OAAO;QACL,SAAS,EAAE,KAAK;QAChB,KAAK,EAAE,QAAQ;QACf,KAAK,EAAE,KAAK;KACb,CAAC;AACJ,CAAC","sourcesContent":["/// <reference types=\"@capacitor/cli\" />\r\n\r\ndeclare module \"@capacitor/cli\" {\r\n  export interface PluginsConfig {\r\n    CapacitorFirestore?: FirestoreConfig;\r\n  }\r\n}\r\n\r\nexport interface FirestoreConfig {\r\n  /**\r\n   * Set the GCP/Firebase project id\r\n   *\r\n   * @since 1.0.0\r\n   * @example \"my-first-project\"\r\n   */\r\n  projectId?: string;\r\n\r\n  /**\r\n   * Set the Firebase application id\r\n   *\r\n   * @since 1.0.0\r\n   * @example \"1:00000000000:web:abc00000000000000000\"\r\n   */\r\n  applicationId?: string;\r\n\r\n  /**\r\n  * Set the Firebase api key\r\n  *\r\n  * @since 1.0.0\r\n  * @example \"XxxxxxxxxxxXXxxxxxxxxx\"\r\n  */\r\n  apiKey?: string;\r\n}\r\n\r\nexport type CallbackId = string;\r\n\r\n/**\r\n * Filter conditions in a {@link QueryConstraint} clause are specified using the\r\n * strings '&lt;', '&lt;=', '==', '&gt;=', '&gt;', 'array-contains'\r\n */\r\nexport type QueryOperators = \"==\" | \">=\" | \"<=\" | \"<\" | \">\" | \"array-contains\";\r\n\r\n/**\r\n * \r\n * @param field The path to compare\r\n * @param operator The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n * \"&lt;=\", \"!=\", \"array-contains\")\r\n * @param value The value for comparison\r\n * @returns The created {@link QueryConstraint}.\r\n */\r\nexport function createQueryConstraint(field: string, operator: QueryOperators, value: any): QueryConstraint {\r\n  return {\r\n    fieldPath: field,\r\n    opStr: operator,\r\n    value: value\r\n  };\r\n}\r\n\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Firestore query.\r\n */\r\nexport interface QueryConstraint {\r\n  /**\r\n   * The path to compare\r\n   */\r\n  fieldPath: string;\r\n\r\n  /**\r\n   * The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n   * \"&lt;=\", \"!=\", \"array-contains\")\r\n   */\r\n  opStr: QueryOperators;\r\n\r\n  /**\r\n   * The value for comparison\r\n   */\r\n  value: any;\r\n}\r\n\r\nexport interface CollectionQuery extends DocumnentQuery {\r\n  queryConstraints?: QueryConstraint[];\r\n}\r\n\r\nexport interface DocumnentQuery {\r\n  /**\r\n   * A reference to the document/collection\r\n   */\r\n  reference: string;\r\n}\r\n\r\nexport interface DocumentReference {\r\n  /**\r\n  * The id of the document.\r\n  *\r\n  * @since 1.0.0\r\n  */\r\n  id: string;\r\n\r\n  /**\r\n   * A string representing the path of the referenced document (relative\r\n   * to the root of the database).\r\n   * @since 1.0.0\r\n   */\r\n  path: string;\r\n}\r\n\r\nexport interface DocumentSnapshot<T> extends DocumentReference {\r\n  /**\r\n   * The fields of the document or null if the document doesn't exist.\r\n   *\r\n   * @since 1.0.0\r\n   */\r\n  data: T | null;\r\n}\r\n\r\nexport interface CollectionSnapshot<T> {\r\n  collection: DocumentSnapshot<T>[];\r\n}\r\n\r\nexport interface CustomToken {\r\n  token: string;\r\n}\r\n\r\nexport interface RemoveSnapshotListener {\r\n  callbackId: CallbackId;\r\n}\r\n\r\nexport interface UpdateDocument<T> extends DocumnentQuery {\r\n  /**\r\n   * An object containing the fields and values with which to\r\n   * update the document. Fields can contain dots to reference nested fields\r\n   * within the document\r\n   */\r\n  data: Partial<T>;\r\n}\r\n\r\nexport interface SetDocument<T> extends DocumnentQuery {\r\n  /**\r\n   * A map of the fields and values for the document.\r\n   */\r\n  data: T;\r\n\r\n  /**\r\n   * Changes the behavior of a `setDocument()` call to only replace the\r\n   * values specified in its data argument. Fields omitted from the `setDocument()`\r\n   * call remain untouched. If your input sets any field to an empty map, all\r\n   * nested fields are overwritten.\r\n   */\r\n  merge?: boolean;\r\n}\r\n\r\nexport interface AddDocument<T> extends DocumnentQuery {\r\n  /**\r\n   * An Object containing the data for the new document.\r\n   */\r\n  data: T;\r\n}\r\n\r\nexport type DocumentSnapshotCallback<T> = (data: DocumentSnapshot<T> | null, err?: any) => void;\r\n\r\nexport type CollectionSnapshotCallback<T> = (data: CollectionSnapshot<T> | null, err?: any) => void;\r\n\r\nexport interface CapacitorFirestorePlugin {\r\n  /**\r\n   * Configure the firestore instance with new configuration options.\r\n   * @param options \r\n   */\r\n  initializeFirestore(options: FirestoreConfig): Promise<void>;\r\n\r\n  /**\r\n   * Login to firestore using a customer JWT token.\r\n   * @param options \r\n   */\r\n  signInWithCustomToken(options: CustomToken): Promise<void>;\r\n\r\n  /**\r\n   * Reads the document referred to by this DocumnentQuery\r\n   * @param options \r\n   * @returns The document snapshot\r\n   */\r\n  getDocument<T>(options: DocumnentQuery): Promise<DocumentSnapshot<T>>;\r\n\r\n  /**\r\n    * Updates fields in the document referred to by the specified DocumnentQuery.\r\n    * The update will fail if applied to a document that does not exist.\r\n    * @param options \r\n    * @returns A `Promise` resolved once the data has been successfully written\r\n    * to the backend (note that it won't resolve while you're offline).\r\n    */\r\n  updateDocument<T>(options: UpdateDocument<T>): Promise<void>;\r\n\r\n  /**\r\n   * Writes to the document referred to by the specified DocumnentQuery.\r\n   * If the document does not yet exist, it will be created.\r\n   * If you provide merge or mergeFields, the provided data can be merged into an existing document.\r\n   * @param options \r\n   * @returns A Promise resolved once the data has been successfully written\r\n   * to the backend (note that it won't resolve while you're offline).\r\n   */\r\n  setDocument<T>(options: SetDocument<T>): Promise<void>;\r\n\r\n  /**\r\n   * Deletes the document referred to by the specified DocumnentQuery.\r\n   * @param options \r\n   * @returns A Promise resolved once the document has been successfully\r\n   * deleted from the backend (note that it won't resolve while you're offline).\r\n   */\r\n  deleteDocument(options: DocumnentQuery): Promise<void>;\r\n\r\n  /**\r\n   * Add a new document to specified `CollectionQuery` with the given data,\r\n   * assigning it a document ID automatically.\r\n   * @param options \r\n   * @returns A `Promise` resolved with a `DocumentReference` pointing to the\r\n   * newly created document after it has been written to the backend (Note that it\r\n   * won't resolve while you're offline).\r\n   */\r\n  addDocument<T>(options: AddDocument<T>): Promise<DocumentReference>;\r\n\r\n  /**\r\n   * Listen for snapshot changes on a document.\r\n   * @param options \r\n   * @param callback\r\n   * @returns The callback id which can be used to remove the listener.\r\n   */\r\n  addDocumentSnapshotListener<T>(options: DocumnentQuery, callback: DocumentSnapshotCallback<T>): Promise<CallbackId>;\r\n\r\n  /**\r\n   * Executes the query and returns the results as a CollectionSnapshot\r\n   * @param options \r\n   * @returns The collection snapshot\r\n   */\r\n  getCollection<T>(options: CollectionQuery): Promise<CollectionSnapshot<T>>;\r\n\r\n  /**\r\n   * Listen for snapshot changes on a collection.\r\n   * @param options \r\n   * @param callback \r\n   * @returns The callback id which can be used to remove the listener.\r\n   */\r\n  addCollectionSnapshotListener<T>(options: CollectionQuery, callback: CollectionSnapshotCallback<T>): Promise<CallbackId>;\r\n\r\n  /**\r\n   * Stop listening for snapshot changes on a document or collection.\r\n   * @param options\r\n   */\r\n  removeSnapshotListener(options: RemoveSnapshotListener): Promise<void>;\r\n\r\n  /**\r\n   * Re-enables use of the network for this Firestore instance after a prior\r\n   * call to {@link disableNetwork}.\r\n   *\r\n   * @returns A `Promise` that is resolved once the network has been enabled.\r\n   */\r\n  enableNetwork(): Promise<void>;\r\n\r\n  /**\r\n   * Disables network usage for this instance. It can be re-enabled via {@link enableNetwork}.\r\n   * While the network is disabled, any snapshot listeners, {@link getDocument}\r\n   * or {@link getCollection} calls will return results from cache, and any write\r\n   * operations will be queued until the network is restored.\r\n   *\r\n   * @returns A `Promise` that is resolved once the network has been disabled.\r\n   */\r\n  disableNetwork(): Promise<void>;\r\n}\r\n"]}